# Standard libraries
from argparse import Namespace
from collections import OrderedDict
from pathlib import Path
from shutil import which
from typing import Any, List, Optional, Union
from contextlib import contextmanager
import sys, os

# Third party libraries
from vunit.ui.source import SourceFile
from vunit.ui import VUnit
from vunit.vhdl_standard import VHDLStandard
from vunit.ostools import Process

# First party libraries
from tsfpga.module import BaseModule
from tsfpga.module_list import ModuleList
from tsfpga.system_utils import create_directory, read_file
from tsfpga.vivado.build_result import BuildResult

from tsfpga.vivado.build_result_checker import BuildResultChecker, SizeChecker


@contextmanager
def suppress_stdout():
    with open(os.devnull, "w") as devnull:
        old_stdout = sys.stdout
        sys.stdout = devnull
        try:
            yield
        finally:
            sys.stdout = old_stdout


class YosysUtilizationParser:
    """
    Used for parsing the utilization report generated by Yosys
    """

    @staticmethod
    def get_size(report: str) -> dict[str, int]:
        indicator_lines = ["=== design hierarchy ===", "Number of cells:"]
        got_indicator = 0

        lines = report.split("\n")
        trim_lines: List[str] = []
        got_indicator = False
        for line in lines:
            if got_indicator >= len(indicator_lines):
                if line.strip():
                    trim_lines.append(line.strip())
                else:
                    # Break on first blank line after result report
                    break
            else:
                if line.strip().startswith(indicator_lines[got_indicator]):
                    got_indicator += 1

        lines_split = [line.split() for line in trim_lines]

        headers = []
        numbers = []
        total_luts = 0

        for header, value in lines_split:
            headers.append(header)
            numbers.append(int(value))

            # Extract total LUTs
            if "LUT" in header:
                total_luts += int(value)


        ret = OrderedDict(zip(headers, numbers))
        ret["Total LUTs"] = total_luts

        return ret
    

class CombinedChecker(SizeChecker):
    """
    Base class for combined checkers where there may be multiple variants of 
    """
    name: str
    key_expr: str

    def check(self, build_result: BuildResult):
        total = 0

        for key, value in build_result.synthesis_size.items():
            if key.startswith(self.key_expr):
                total += value

        return self._check_result_value(name=self.name, result_value=total)
    

class TotalLuts(CombinedChecker):
    """
    Combined checker for all LUT types output by Yosys for Xilinx builds
    """
    name = "Total LUTs"
    key_expr = "LUT"

    
class Ffs(CombinedChecker):
    """
    Combined checker for all FF types output by Yosys for Xilinx builds
    """
    name = "Total FFs"
    key_expr = "FD"


class DspBlocks(CombinedChecker):
    """
    Combined checker for all DSP48 types output by Yosys for Xilinx builds
    """
    name = "Total DSP blocks"
    key_expr = "DSP"


class Srls(CombinedChecker):
    """
    Combined checker for all SRL types output by Yosys for Xilinx builds
    """
    name = "SRLs"
    key_expr = "SRL"

class Ramb18(CombinedChecker):
    """
    Combined checker for all RAMB18 types output by Yosys for Xilinx builds
    """
    name = "RAMB18"
    key_expr = "RAMB18"

class Ramb36(CombinedChecker):
    """
    Combined checker for all RAMB18 types output by Yosys for Xilinx builds
    """
    name = "RAMB36"
    key_expr = "RAMB36"

class Ramb(BuildResultChecker):
    """
    Combined checker for RAMB18 and RAMB36 count.
    Each RAMB18 counts as half a RAMB36
    """

    def check(self, build_result: BuildResult):
        total = 0

        for key, value in build_result.synthesis_size.items():
            if key.startswith(Ramb18.key_expr):
                total += value / 2
            elif key.startswith(Ramb36.key_expr):
                total += value

        return self._check_result_value(name=self.name, result_value=total)


class YosysNetlistBuild:
    def __init__(
        self,
        name: str,
        top: str,
        top_module: "BaseModule",
        modules: Optional["ModuleList"] = None,
        synth_command: Optional[str] = None,
        generics: Optional[dict[str, Any]] = None,
        ghdl_path: Optional[Path] = None,
        yosys_path: Optional[Path] = None,
        defined_at: Optional[Path] = None,
        vhdl_standard: VHDLStandard = VHDLStandard("2008"),
        build_result_checkers: Optional[list["SizeChecker"]] = None,
        **other_arguments: Any,
    ):
        self.name = name

        self.top_module = top_module
        self.modules = ModuleList() if modules is None else modules.copy()
        self.modules.append(top_module)

        if synth_command is not None:
            assert synth_command.startswith("synth"), "Must be Yosys synth command"
        self.synth_command = synth_command

        self.static_generics = {} if generics is None else generics.copy()
        self._ghdl_path = ghdl_path
        self._yosys_path = yosys_path
        self.defined_at = defined_at
        self.other_arguments = None if other_arguments is None else other_arguments.copy()

        self.top = top

        self.is_netlist_build = True
        self.analyze_synthesis_timing = False

        self._vhdl_standard = vhdl_standard

        self.build_result_checkers = [] if build_result_checkers is None else build_result_checkers

        self._vunit_proj = self._create_vunit_project(self.modules)

        # Order in which libraries are compiled, and hence the order
        # in which they need to be loaded into Yosys.
        self._library_compile_order = []

        self._implementation_subset = None

    def open(self):
        """
        Yosys netlist build can't be opened.
        """
        raise NotImplementedError("Yosys netlist build can't be opened")
    
    def create(self):
        """
        Yosys netlist build can't be created.
        """
        raise NotImplementedError("Yosys netlist build can't be created")

    def __str__(self) -> str:
        result = f"{self.name}\n"

        if self.defined_at is not None:
            result += f"Defined at: {self.defined_at.resolve()}\n"

        result += f"Type:       {self.__class__.__name__}\n"
        result += f"Top level:  {self.top}\n"

        if self.static_generics:
            generics = self._dict_to_string(self.static_generics)
        else:
            generics = "-"
        result += f"Generics:   {generics}\n"

        if self.other_arguments:
            result += f"Arguments:  {self._dict_to_string(self.other_arguments)}\n"

        return result

    @staticmethod
    def _dict_to_string(data: dict[str, Any]) -> str:
        return ", ".join([f"{name}={value}" for name, value in data.items()])

    def _create_vunit_project(sel, modules: ModuleList) -> VUnit:

        dummy_args = Namespace()
        dummy_args.output_path = Path("out")
        dummy_args.log_level = "error"
        dummy_args.no_color = True
        dummy_args.clean = False

        with suppress_stdout():
            vunit_proj = VUnit.from_args(args=dummy_args)

        for module in modules:
            vunit_library = vunit_proj.add_library(
                library_name=module.library_name, allow_duplicate=True
            )
            for hdl_file in module.get_synthesis_files():
                vunit_library.add_source_file(hdl_file.path)

        return vunit_proj
    
    def _get_ghdl_path(self) -> str:
        if self._ghdl_path is not None:
            return self._ghdl_path.resolve()

        which_ghdl = which("ghdl")
        if which_ghdl is None:
            raise FileNotFoundError("Could not find ghdl on PATH")

        return Path(which_ghdl).resolve().as_posix()

    def _get_yosys_path(self) -> str:
        if self._yosys_path is not None:
            return self._yosys_path.resolve().as_posix()

        which_yosys = which("yosys")
        if which_yosys is None:
            raise FileNotFoundError("Could not find yosys on PATH")

        return Path(which_yosys).resolve().as_posix()

    def _get_top_file(self) -> Optional[SourceFile]:
        """
        Returns top level, assumes file is named the same as top level entity.
        Top level must be VHDL.
        """

        top_file_pattern = "*/" + self.top + ".vhd"

        vhd_top_file = self._vunit_proj.get_source_file(
            top_file_pattern, library_name=self.top_module.library_name
        )

        return vhd_top_file

    def _get_required_synthesis_files(self) -> List[SourceFile]:
        """
        Create a list of of only the required files for the top level in the correct compile order.
        Assumes top level file has same name as the source file it is defined in.
        """

        if self._implementation_subset is None:
            top_file = self._get_top_file()

            self._implementation_subset = self._vunit_proj.get_implementation_subset([top_file])

            for file in reversed(self._implementation_subset):
                if file.library.name not in self._library_compile_order:
                    self._library_compile_order.insert(0, file.library.name)

        return self._implementation_subset

    def _get_synth_command(self) -> str:
        if self.synth_command is None:
            command = "synth"
        else:
            command = self.synth_command

        command += f" -top {self.top}"

        return command

    def _get_ghdl_standard_option(self) -> str:
        return "--std=" + self._vhdl_standard._standard[2:]

    def _get_ghdl_generics(self) -> List[str]:
        return [f"-g{key}={val}" for key, val in self.static_generics.items()]

    def _ghdl_analyze_file(self, file: SourceFile, cwd: Path) -> bool:
        file_path = Path(file.name).resolve().absolute().as_posix()

        cmd = [
            self._get_ghdl_path(),
            "-a",
            self._get_ghdl_standard_option(),
            f"--workdir={cwd}",
            f"-P={cwd}",
            f"--work={file.library.name}",
            file_path,
        ]

        print(f"GHDL: Analyzing file {file.name} into library {file.library.name}")

        try:
            Process(args=cmd, cwd=cwd).consume_output()
        except Process.NonZeroExitCode:
            return False
        else:
            return True

    def _get_vhdl_files(self) -> List[SourceFile]:
        files = self._get_required_synthesis_files()
        return [file for file in files if file.name.endswith(".vhd")]

    def _get_verilog_files(self) -> List[SourceFile]:
        files = self._get_required_synthesis_files()
        return [file for file in files if file.name.endswith(".v")]

    def _ghdl_analyze(self, output_path: Path) -> bool:
        success = False

        for file in self._get_vhdl_files():
            success = self._ghdl_analyze_file(file, output_path)
            if not success:
                return success

        return success

    def _ghdl_synthesize(self, output_path: Path) -> Optional[Path]:
        """
        Convert top level to Verilog using GHDL
        """
        top_file = self._get_top_file()
        top_file_path = Path(top_file.name)
        top_library = top_file.library.name

        top_unit = top_file_path.stem

        ghdl_workdir = output_path / "ghdl"
        output_file = output_path / "ghdl" / f"{top_unit}.v"

        cmd = [
            self._get_ghdl_path(),
            "--synth",
            f"-o={output_file}",
            "--out=verilog",
            "--no-formal",
            self._get_ghdl_standard_option(),
            f"--workdir={ghdl_workdir}",
            f"-P={ghdl_workdir}",
            f"--work={top_library}",
        ]

        cmd.extend(self._get_ghdl_generics())

        cmd.append(top_unit)

        print(f"Synthesizing {top_file_path} into Verilog")

        try:
            Process(args=cmd, cwd=output_path).consume_output()
        except Process.NonZeroExitCode:
            return None
        else:
            return output_file

    def _create_script(self, top_file: Path) -> str:

        script = []

        # Load converted top level file
        script.append(f"read_verilog {top_file.resolve().as_posix()}")

        for file in self._get_verilog_files():
            file_path = Path(file.name).resolve().absolute().as_posix()

            script.append(f"read_verilog {file_path}")


        # Set synthesis command
        script.append(self._get_synth_command())

        script.append("hilomap -hicell VCC P -locell GND G")

        script.append("write_edif -nogndvcc test.edif")

        # Create script command
        script_str = "; ".join(script)

        return script_str

    def _run_yosys(self, top_file: Path, output_path: Path, ghdl_output_path: Path) -> BuildResult:

        script = self._create_script(top_file)
        print(script)

        cmd = [self._get_yosys_path(), "-p", script]

        result = BuildResult(self.name)

        try:
            Process(args=cmd, cwd=output_path).consume_output()
        except Process.NonZeroExitCode:
            result.success = False
        else:
            result.success = True

        return result

    def _get_size(self, output_path: Path):
        report_as_string = read_file(output_path / "output.txt")

        return YosysUtilizationParser.get_size(report_as_string)

    def build(self, project_path: Path, output_path: Path, **kwargs) -> bool:

        ghdl_output_path = output_path / "ghdl"
        create_directory(ghdl_output_path, empty=True)

        success = self._ghdl_analyze(ghdl_output_path)
        if not success:
            raise RuntimeError("GHDL analysis failed")

        top_file = self._ghdl_synthesize(output_path)

        if not top_file:
            raise RuntimeError("GHDL synthesis failed")

        result = self._run_yosys(top_file, output_path, ghdl_output_path)

        result.synthesis_size = self._get_size(output_path)

        result.success = result.success and self._check_size(result)

        return result
    
    def _check_size(self, build_result: BuildResult) -> bool:
        if not build_result.success:
            print(f"Can not do post_build check for {self.name} since it did not succeed.")
            return False

        success = True
        for build_result_checker in self.build_result_checkers:
            checker_result = build_result_checker.check(build_result)
            success = success and checker_result

        return success


class YosysXilinxNetlistBuild(YosysNetlistBuild):
    def __init__(
        self,
        name,
        top,
        top_module,
        modules=None,
        generics=None,
        family=None,
        ghdl_path=None,
        yosys_path=None,
        defined_at=None,
        vhdl_standard=VHDLStandard("2008"),
        **other_arguments,
    ):
        synth_command = "synth_xilinx"

        if family:
            synth_command += f"-family {family}"

        super().__init__(
            name,
            top,
            top_module,
            modules,
            synth_command,
            generics,
            ghdl_path,
            yosys_path,
            defined_at,
            vhdl_standard,
            **other_arguments,
        )
